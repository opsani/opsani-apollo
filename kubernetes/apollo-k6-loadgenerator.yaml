---
apiVersion: apps/v1
kind: Deployment

metadata:
  name: k6
  labels:
    app: k6
    app.kubernetes.io/name: k6

spec:
  replicas: 1
  revisionHistoryLimit: 2
  selector:
    matchLabels:
      app: k6
      app.kubernetes.io/name: k6
  template:
    metadata:
      labels:
        app: k6
        app.kubernetes.io/name: k6
    spec:
      # Prefer deployment onto a Node labeled node.opsani.com=servo
      # This ensures physical isolation and network transport if possible
      affinity:
        nodeAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 1
            preference:
              matchExpressions:
              - key: node.opsani.com/role
                operator: In
                values:
                - servo
      containers:
      - name: k6
        image: loadimpact/k6:latest
        command: ["k6"]
        args: ["run", "/scripts/fiber-http-varload.js"]
        env:
        - name: K6_NO_SUMMARY
          value: "TRUE"
        - name: K6_NO_THRESHOLDS
          value: "TRUE"
        resources:
          limits:
            cpu: "2"
            memory: 2Gi
          requests:
            cpu: "0.5"
            memory: 0.5Gi
        volumeMounts:
        - name: k6-scripts-volume
          mountPath: /scripts
      volumes:
      - name: k6-scripts-volume
        configMap:
          name: k6-scripts
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: k6-scripts
data:
  fiber-http-varload.js: |
    import http from 'k6/http';
    export let options = {
      discardResponseBodies: true,
      noVUConnectionReuse: true,
      minIterationDuration: 0,
      scenarios: {
        contacts: {
          executor: 'constant-vus',
          vus: 500,
          duration: '24h',
        },
      },
    };
    export default function () {
      const durationInSeconds = 10;
      const url = "http://apollo:8080/";
      const requests = buildBatch(url, 10);
      const before = new Date().getTime();
      while (true) {
        http.get(url);
        //or
        // http.batch(requests);
        const after = new Date().getTime();
        const diff = (after - before) / 1000;
        const remainder = durationInSeconds - diff;
        if (remainder <= 0) {
          break;
        }
      }
    };
    function buildBatch(url, size) {
      let request = {
        method: 'GET',
        url: url,
      };
      let requests = [];
      for (let i = 0; i < size; i++) {
        requests.push(request);
      }
      return requests;
    }